\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings, xcolor}
%\lstset{%numbers=left, %设置行号位置
%        %numberstyle=\tiny, %设置行号大小
%        keywordstyle=\color{blue}, %设置关键字颜色
%        commentstyle=\color[cmyk]{1,0,1,0}, %设置注释颜色
%        frame=single, %设置边框格式
%        escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
%        breaklines, %自动折行
%        extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
%        xleftmargin=1em,xrightmargin=2em, aboveskip=1em, %设置边距
%        tabsize=4, %设置tab空格数
%        showspaces=false %不显示空格
%       }
%\lstset{numbers=left, language=Java, 
%numberstyle=\tiny, 
%keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}, 
%frame=shadowbox, 
%rulesepcolor=\color{red!20!green!20!blue!20},escapeinside=“, xleftmargin=2em,xrightmargin=2em, aboveskip=1em, breaklines}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

\title{Project 1 - Build a thread system for kernel processes}
\author{Xie Yuanhang\\ 2011012344\and
Kuang Zhonghong\\ 2011012357\and
Li Qingyang\\ 2011012360\and
Yin Mingtian\\ 2011012362\and
Wang Qinshi\\ 2012011311}
\date{}
\begin{document}
\maketitle
\tableofcontents{}
\section{Implementation of \texttt{KTread.join()}}
\subsection{Overview}
In this task, we need to implement \texttt{KThread.join()}, and the method should 
\begin{enumerate}
	\item[$\bullet$] if this is finished return immediately
	\item[$\bullet$] be called only once
	\item[$\bullet$] store currentThread and wake it later
	\item[$\bullet$] assure that the thread finish executing normally
\end{enumerate}
\subsection{Correctness Constraints}
\begin{enumerate}
	\item[$\bullet$] Corner cases: when this equals to currentThread or this is already finished, return immediately
	\item[$\bullet$] Need to be atomic by disable interruption and restore interruption at last
	\item[$\bullet$] When this thread finish, it should wake the stored thread
\end{enumerate}
\subsection{Declaration}
\begin{enumerate}
	\item[$\bullet$] Add new state variable \texttt{waitQueue} which is a \texttt{ThreadQueue(true)} into \texttt{KThread}.
	\item[$\bullet$] Modification of \texttt{join()}:
		Firstly, disable interruption to make the operation atomic and restore it at last; 
		secondly, prevent joining itself and prevent a finished thread from joining others, otherwise, let the currentThread sleep to wait this method finish.
	\item[$\bullet$] Modification of \texttt{finish()}:
		Assure that once this method is finished, wake the thread join it to let the joining thread normally continue executing.
\end{enumerate}
\subsection{Description}
Shown in pseudocode.
\begin{algorithm}
  \begin{algorithmic}
    \Procedure {join()}{}
			\State Disable Interruption
				\If{currentThread == this or this.status == statusFinished}
					\State Restore Interruption
					\State \Return
				\Else
					\State add currentThread into waitQueue
					\State currentThread sleep
				\EndIf
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {finish()}{}
			\State ...
			\State currentThread.status = statusFinished
			\State Ready thread in waitQueue
			\State sleep()
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\subsection{Test}
Using \texttt{selfTest()} method in \texttt{KThread}, the main thought is making some \texttt{join} example, so we have those test below.
\begin{lstlisting}[language=java]
	private static void test1(){
		//Test Case 1
		System.out.println("\n*** Test Case 1 for join ***");
		ToJoin toJoin = new ToJoin();
		KThread toJoinThread = new KThread(toJoin).setName("ToJoin Thread");
		KThread toBeJoinedThread = new KThread(new ToBeJoined(toJoinThread)).setName("ToBeJoined Thread");
		toBeJoinedThread.fork();
		toJoinThread.fork();
		ThreadedKernel.alarm.waitUntil(100000);
	}
	private static void test2(){
		//Test Case 2
		System.out.println("\n*** Test Case 2 for join ***");
		ToJoin toJoin = new ToJoin();
		KThread toJoinThread = new KThread(toJoin).setName("ToJoin Thread");
		KThread toBeJoinedThread = new KThread(new ToBeJoined(toJoinThread)).setName("ToBeJoined Thread");
		toJoinThread.fork();
		toBeJoinedThread.fork();
		ThreadedKernel.alarm.waitUntil(100000);
	}
	private static void test3(){
		//Test Case 3
		System.out.println("\n*** Test Case 3 for join ***");
		ToJoin toJoin = new ToJoin();
		KThread toJoinThread = new KThread(toJoin).setName("ToJoin Thread");
		KThread toBeJoined1 = new KThread(new ToBeJoined(toJoinThread)).setName("ToBeJoined1 Thread");
		KThread toBeJoined2 = new KThread(new ToBeJoined(toJoinThread)).setName("ToBeJoined2 Thread");
		toBeJoined1.fork();
		toBeJoined2.fork();
		toJoinThread.fork();
		ThreadedKernel.alarm.waitUntil(100000);
	}
	private static void test4(){
		//Test Case 4
		System.out.println("\n*** Test Case 4 for join ***");
		ToJoin toJoin1 = new ToJoin();
		ToJoin toJoin2 = new ToJoin();
		KThread t1 = new KThread(toJoin1).setName("ToJoin Thread 1");
		KThread t2 = new KThread(toJoin2).setName("ToJoin Thread 2");
		KThread toBeJoined = new KThread(new ToBeJoinedCouple(t1,t2)).setName("ToBeJoined Thread");
		toBeJoined.fork();
		t1.fork();
		t2.fork();
		ThreadedKernel.alarm.waitUntil(100000);
	}
\end{lstlisting}
And the result of such test is as bellow.
\begin{lstlisting}
*** Test Case 1 for join ***
* ToBeJoined starts running
* ToJoin joins
* ToJoin starts running
* ToJoin ends running
* ToBeJoined continues running after ToJoin Thread finishes

*** Test Case 2 for join ***
* ToJoin starts running
* ToJoin ends running
* ToBeJoined starts running
* ToJoin joins
* ToBeJoined continues running after ToJoin Thread finishes

*** Test Case 3 for join ***
* ToBeJoined starts running
* ToJoin joins
* ToBeJoined starts running
* ToJoin joins
* ToJoin starts running
* ToJoin ends running
* ToBeJoined continues running after ToJoin Thread finishes
* ToBeJoined continues running after ToJoin Thread finishes

*** Test Case 4 for join ***
* ToBeJoinedCouple starts running
* ToJoin Thread 1 joins
* ToJoin starts running
* ToJoin ends running
* ToJoin starts running
* ToJoin ends running
* ToJoin Thread 2 joins
* ToBeJoinedCouple continues running after two joining threads
\end{lstlisting}

\begin{enumerate}
\item For \texttt{test1}, we have the thread being joined run first, and have the other thread join the former run after;
\item For \texttt{test2}, just the running order of the thread different from the first test;
\item For \texttt{test3}, we have a thread join two different threads;
\item For \texttt{test4}, we have a thread be joined by two different threads;
\end{enumerate}

And the right results for all the tests must have the joined thread finished before the threads which join them continue. So we have the tests above is right, and by these tests, our \texttt{join} is right.
\section{Implementation of \texttt{Condition2}}
\subsection{Overview}
Implement \texttt{Condition2} without using semaphore and \texttt{Condition2} must be equivalent implementation as \texttt{Condition}.
\subsection{Correctness Constraints}
\begin{enumerate}
	\item[$\bullet$] \texttt{sleep} method:
		\begin{enumerate}
			\item[-] Atomically release the associated lock and put the current thread to sleep until be waken
			\item[-] The associated lock must be held by current thread before the method and re-required after this method.
		\end{enumerate}
	\item[$\bullet$] \texttt{wake} method:
		\begin{enumerate}
			\item[-] Atomically wake up a thread which called \texttt{sleep}
			\item[-] The associated lock must be held by current thread before the method.
		\end{enumerate}
	\item[$\bullet$] \texttt{wakeAll} method:
		\begin{enumerate}
			\item[-] Atomically wake up all thread which called \texttt{sleep} on this condition
			\item[-] The associated lock must be held by current thread before the method.
		\end{enumerate}
\end{enumerate}
\subsection{Declaration}
\begin{enumerate}
	\item[$\bullet$] Add new state variable \texttt{waitQueue} which is a \texttt{ThreadQueue} into \texttt{Condition2}.
	\item[$\bullet$] \texttt{sleep} method: place currentThread into ThreadQueue and release the lock, then sleep the currentThread and then 
		re-acquire the lock when it return from \texttt{sleep}
	\item[$\bullet$] \texttt{wake} method: remove the thread from the waitQueue and put it on the ready Queue
	\item[$\bullet$] \texttt{wakeAll} method: remove all threads from the waitQueue and put them on the ready Queue
\end{enumerate}
\subsection{Description}
\begin{algorithm}
  \begin{algorithmic}
    \Procedure {sleep()}{}
			\State Lib.assertTrue conditionLock.isHeldByCurrentThread
			\State Disable Interruption
			\State Add currentThread into waitQueue
			\State Release the conditionLock
			\State currentThread sleep
			\State Acquire the conditionLock
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {wake()}{}
			\State Lib.assertTrue conditionLock.isHeldByCurrentThread
			\State Disable Interruption
			\If{waitQueue is not empty}
				\State Remove and wake the first thread in waitQueue
			\EndIf
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {wakeAll()}{}
			\State Lib.assertTrue conditionLock.isHeldByCurrentThread
			\State Disable Interruption
			\While{waitQueue is not empty}
				\State Remove and wake the first thread in waitQueue
			\EndWhile
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\subsection{Test}
Using \texttt{selfTest()} in \texttt{Condition2},

In this session, the test is using \texttt{Condition} and \texttt{Condition2} to do the same job, and compare their results, and then we finish the test. Here are the codes.
\begin{lstlisting}
public static void selfTest(){
	Int goods = new Int(0);
	Lock lock = new Lock();
	Condition2 condition = new Condition2(lock);
	KThread consumer1 = new KThread(new Consumer(1, goods, condition, lock));
	KThread consumer2 = new KThread(new Consumer(2, goods, condition, lock));
	KThread producer1 = new KThread(new Producer(1, goods, condition, lock));
	KThread producer2 = new KThread(new Producer(2, goods, condition, lock));
	KThread producer3 = new KThread(new Producer(3, goods, condition, lock));
	KThread consumer3 = new KThread(new Consumer(3, goods, condition, lock));
	consumer1.fork();
	consumer2.fork();
	producer1.fork();
	producer2.fork();
	producer3.fork();
	consumer3.fork();
	ThreadedKernel.alarm.waitUntil(100000);
}
\end{lstlisting}
And for \texttt{Condition}, we just change the test code above. And here are the results.
\begin{lstlisting}
using condition2:
Consumer 1 starts running
Consumer 1 sleeps (0 items)
Consumer 2 starts running
Consumer 2 sleeps (0 items)
Producer 1 starts running
Producer 1 produces 1 item (1 items)
Producer 1 ends running
Producer 2 starts running
Producer 2 produces 1 item (2 items)
Producer 2 ends running
Producer 3 starts running
Producer 3 produces 1 item (3 items)
Producer 3 ends running
Consumer 3 starts running
Consumer 3 consumes 1 item (2 items)
Consumer 3 ends running
Consumer 1 consumes 1 item (1 items)
Consumer 1 ends running
Consumer 2 consumes 1 item (0 items)
Consumer 2 ends running

using condition:
Consumer 1 starts running
Consumer 1 sleeps (0 items)
Consumer 2 starts running
Consumer 2 sleeps (0 items)
Producer 1 starts running
Producer 1 produces 1 item (1 items)
Producer 1 ends running
Producer 2 starts running
Producer 2 produces 1 item (2 items)
Producer 2 ends running
Producer 3 starts running
Producer 3 produces 1 item (3 items)
Producer 3 ends running
Consumer 3 starts running
Consumer 3 consumes 1 item (2 items)
Consumer 3 ends running
Consumer 1 consumes 1 item (1 items)
Consumer 1 ends running
Consumer 2 consumes 1 item (0 items)
Consumer 2 ends running
\end{lstlisting}
And it's easy to see that they are the same, and in this test, \texttt{Condition2} is right.
\section{Implementation of \texttt{Alarm}}
\subsection{Overview}
Implementation of \texttt{Alarm} class, such that after the thread called \texttt{waitUtill(x)} at time \texttt{t} then \texttt{timerInterrupt} 
wake the thread after time \texttt{x+t}.
\subsection{Correctness Constraints}
\begin{enumerate}
	\item[$\bullet$] \texttt{waitUtill} method: Move the calling thread into waitQueue and block the thread. 
	\item[$\bullet$] \texttt{timerInterrupt} method: The thread should be woken when the interval on the call is over.
\end{enumerate}
\subsection{Declaration}
\begin{enumerate}
	\item[$\bullet$] Create a new class \texttt{WaitThread} which contains a thread and its wake time. 
Add a new instance variable \texttt{waitQueue} of \texttt{WaitThread} which is a \texttt{PriorityQueue} with wake time as priority. 
	\item[$\bullet$] \texttt{waitUtill} method: Calculate the wake time by adding x to current time and the \texttt{WaitThread} of the thread
		should be store in waitQueue which is a priority queue(hence is efficient).
	\item[$\bullet$] \texttt{timerInterrupt} method: use a while loop to wake threads whose wake time is less than current time.
\end{enumerate}
\subsection{Description}
\begin{algorithm}
  \begin{algorithmic}
    \Procedure {waitUntil}{x}
			\State Disable Interruption
			\State Calculate the wake time(x + currentTime) and create a waitThread
			\State Put waitThread into waitQueue
			\State sleep this thread
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {timerInterrupt()}{}
			\State Disable Interruption
			\While{waitQueue is not empty AND wake time of first thread in waitQueue $<$ currentTime}
					\State wake first thread in waitQueue
			\EndWhile
			\State Restore Interruption
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
 \subsection{Test}
 Call \texttt{waitUtill} by several threads and print the calling time and the wake time. Find out whether the threads are waken after wake time. 
 
 So the codes are as follows.
 \begin{lstlisting}
public static void selfTest(){
	KThread[] t = new KThread[10];
	for(int i = 0; i < 10; i++){
		t[i] = new KThread(new AlarmTest((long)((i+1) * 100)));
		t[i].fork();
	}
	ThreadedKernel.alarm.waitUntil(100000);
}
 \end{lstlisting}
 
 And the result is as follows.
\begin{lstlisting}
Thread starts at 120
Thread calls waitUtill with delay 100
Thread starts at 130
Thread calls waitUtill with delay 200
Thread starts at 140
Thread calls waitUtill with delay 300
Thread starts at 150
Thread calls waitUtill with delay 400
Thread starts at 160
Thread calls waitUtill with delay 500
Thread starts at 170
Thread calls waitUtill with delay 600
Thread starts at 180
Thread calls waitUtill with delay 700
Thread starts at 190
Thread calls waitUtill with delay 800
Thread starts at 200
Thread calls waitUtill with delay 900
Thread starts at 210
Thread calls waitUtill with delay 1000
Thread recovers at 500 (500>=120+100)
Thread recovers at 510 (510>=130+200)
Thread recovers at 520 (520>=140+300)
Thread recovers at 1030 (1030>=150+400)
Thread recovers at 1040 (1040>=160+500)
Thread recovers at 1050 (1050>=170+600)
Thread recovers at 1060 (1060>=180+700)
Thread recovers at 1070 (1070>=190+800)
Thread recovers at 1540 (1540>=200+900)
Thread recovers at 1550 (1550>=210+1000)
\end{lstlisting}

And the test accurately meet the needs.
\section{Implementation of \texttt{Communicator}}
\subsection{Overview}
Implementat \texttt{Communicator} class. Two methods \texttt{speak} and \texttt{listener} to implement. The message is passed from exactly one 
speaker to exactly one listener.
\subsection{Correctness Constraints}
\begin{enumerate}
	\item[$\bullet$] Listeners wait when there is no speaker
	\item[$\bullet$] Speakers wait when there is no listener
\end{enumerate}
\subsection{Declaration}
\begin{enumerate}
	\item[$\bullet$] Add a state variable \texttt{lock} which is a \texttt{Lock} into \texttt{Communicator}. 
		Add four counters \texttt{AS, WS, AL, WL} initially as 0. Add three \texttt{condition}s for speaker, listener and return with the same lock.
		Add a state variable \texttt{word} to store words from speakers.
	\item[$\bullet$] Note that the first speaker or listener is what we call active speaker
		or listener and is exchanging message and sleep on condition utill other one wakes it up and both return.
	\item[$\bullet$] A speaker speaks to only one listener and a listener listens to only one speaker, so the waiting speaker(listener) will be 
		blocked by active speaker(listener).
\end{enumerate}
\subsection{Description}
\begin{algorithm}
  \begin{algorithmic}
    \Procedure {Communicator()}{}
			\State initialize lock
			\State initialize AS WS AL WL to 0
			\State initialize conditions with same lock
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {speak}{word}
			\State Acquire the lock
			\While{AS != 0}
				\State WS$++$
				\State $//$ sleep on condition speaker
				\State sleep
				\State WS$--$
			\EndWhile
			\State AS$++$
			\State set word
			\If{AL != 0}
				\State Wake active listener
			\Else
				\If{WL != 0}
					\State wake one listener
				\EndIf
				\State $//$ in case that the later speaker runs too fast and cover the word
				\State $//$ sleep on condition return
				\State sleep till the wait listener to return 		
				\State AS--
				\State AL--
				\If{WS != 0}
					\State wake the wait speaker
				\EndIf
			\EndIf
			\State Release the lock
			\State \Return
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}
    \Procedure {listener()}{}
			\State Acquire the lock
			\While{AL != 0}
				\State WL$++$
				\State $//$ sleep on condition listener
				\State sleep
				\State WL$--$
			\EndWhile
			\State AL$++$
			\If{AS != 0}
				\State Wake active speaker
			\Else
				\If{WS != 0}
					\State wake one speaker
				\EndIf
				\State $//$ in case that the later listener runs too fast and retreive the word
				\State $//$ sleep on condition return
				\State sleep till the wait speaker to return 		
				\State AL--
				\State AS--
				\If{WL != 0}
					\State wake the wait listener
				\EndIf
			\EndIf
			\State retreive word
			\State Release the lock
			\State \Return
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\subsection{Test}
Test a senquence of speakers and listeners in different orders and check the output.

And the test code as follows.
\begin{lstlisting}
public static void selfTest() {
	Communicator com = new Communicator();
	/* case 1 
	(new KThread(new Listener(1, com))).fork();
	(new KThread(new Listener(2, com))).fork();
	(new KThread(new Speaker(1, com, 1))).fork();
	(new KThread(new Speaker(2, com, 2))).fork();
	(new KThread(new Speaker(3, com, 3))).fork();
	(new KThread(new Listener(3, com))).fork();
	*/
	///* case 2
	for(int i = 1; i < 6; i++){
		(new KThread(new Listener(i, com))).fork();
	}
	for(int i = 5; i > 0; i--){
		(new KThread(new Speaker(i, com, i))).fork();	
	}
	//*/
	ThreadedKernel.alarm.waitUntil(100000);
}
\end{lstlisting}

And the results is as follows.
\begin{lstlisting}
case 1
Listener 1 starts listening
Listener 2 starts listening
Speaker 1 starts speaking
Speaker 1 speaks 1
Speaker 1 ends speaking
Speaker 2 starts speaking
Speaker 3 starts speaking
Listener 3 starts listening
Listener 1 hears 1 from speaker 1
Listener 1 ends listening
Speaker 2 speaks 2
Speaker 2 ends speaking
Listener 2 hears 2 from speaker 2
Listener 2 ends listening
Speaker 3 speaks 3
Speaker 3 ends speaking
Listener 3 hears 3 from speaker 3
Listener 3 ends listening

case 2
Listener 1 starts listening
Listener 2 starts listening
Listener 3 starts listening
Listener 4 starts listening
Listener 5 starts listening
Speaker 5 starts speaking
Speaker 5 speaks 5
Speaker 5 ends speaking
Speaker 4 starts speaking
Speaker 3 starts speaking
Speaker 2 starts speaking
Speaker 1 starts speaking
Listener 1 hears 5 from speaker 5
Listener 1 ends listening
Speaker 4 speaks 4
Speaker 4 ends speaking
Listener 2 hears 4 from speaker 4
Listener 2 ends listening
Listener 3 hears 3 from speaker 3
Listener 3 ends listening
Speaker 3 speaks 3
Speaker 3 ends speaking
Speaker 2 speaks 2
Speaker 2 ends speaking
Listener 4 hears 2 from speaker 2
Listener 4 ends listening
Speaker 1 speaks 1
Speaker 1 ends speaking
Listener 5 hears 1 from speaker 1
Listener 5 ends listening
\end{lstlisting}

And we finish our test, and by the results, we have the \texttt{Communicator} right.
\section{Implementation of \texttt{PriorityScheduler}}
\subsection{Overview}
Implement \texttt{PriorityScheduler} class so that the scheduler can properly schedule the threads by its priority and by priority donation 
we can avoid priority inversion.
\subsection{Correctness Constraints}
\begin{enumerate}
	\item[$\bullet$] Waiting thread donates its priority to the thread which is holding the resource to avoid priority inversion.
	\item[$\bullet$] Scheduler always retreive the thread with highest priority from the waitingQueue.
\end{enumerate}
\subsection{Declaration}
\begin{enumerate}
	\item[$\bullet$] Here we only consider the case \texttt{transferPriority} is true, since when it's false, we only have to sort the threads by 
		their o riginal priority and don't need to calculate \texttt{EP}.
	\item[$\bullet$] In \texttt{PriorityQueue}: \\
		Add \texttt{waitingList}: a priority-queue(realized by maximal heap or red-black tree) by EP of \texttt{ThreadState} waiting for this resource.
		Add a \texttt{maxEP} denotes maximal EP in the \texttt{waitingQueue}.
		Add a \texttt{boolean} \texttt{changed} denotes whether \texttt{maxEP} should be updated.
		Add a \texttt{ThreadState} \texttt{master} which is occupying the resource.
	\item[$\bullet$] In \texttt{ThreadState}: \\
		Add a list by EP of \texttt{PriorityQueue} \texttt{occupiedResources} collects the resources which is now occupied by this thread. 
		Add a list by EP of \texttt{PriorityQueue} \texttt{acquiredResources} collects the resources which is being acquired(but no yet) by this thread.
		Add a \texttt{boolean} \texttt{changed} denotes whether \texttt{EP} should be updated.
		Add a \texttt{EP} denotes EP of this thread.
	\item[$\bullet$] The EP should be recursively updated when a new waiting thread enter or when a thread quit holding resources. 
		And updated by rules: Waiting thread donates its priority to the thread which is holding the resource to avoid priority inversion.
\end{enumerate}
\subsection{Description}
\begin{algorithm}
	\caption{PriorityQueue}
	\begin{algorithmic}
		\Procedure {getMaxEP()}{}
			\If{!transferPriority}
				\State \Return minimum priority
			\EndIf
			\If{changed}
				\State maxEP $\leftarrow$ minimum priority
				\For{each ThreadState ts in waitingQueue}
					\State temp $\leftarrow$ MAX(maxEP, ts.getEP())
				\EndFor
				changed $\leftarrow$ false
			\EndIf
			\State \Return maxEP
		\EndProcedure
	\end{algorithmic}
	\begin{algorithmic}
    \Procedure {waitForAccess}{KThread thread}
			\State Lib.assertTrue(Machine.interrupt.disable()))
			\State Add (ts $\leftarrow$ getThreadState(thread)) into waitingQueue
			\State ts.waitForAccess(this)
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {acquire}{KThread thread}
			\State Lib.assertTrue(Machine.interrupt.disable()))
			\If{master != null}
				\State Remove this from master.occupiedResource
			\EndIf
			\State getThreadState(thread).acquire(this)
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {nextThread()}{}
			\State Lib.assertTrue(Machine.interrupt.disable()))
			\If{master != null}
				\State Remove this from master.occupiedResource
			\EndIf
			\State thread $\leftarrow$ null
			\If{waitingQueue is not empty}
				\State thread $\leftarrow$ pickNextThread()
				\State Remove thread from waitingQueue
				\State thread.acquire(this)
			\EndIf
			\State \Return thread
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}
    \Procedure {pickNextThread()}{}
		\If{waitingQueue is not empty}
			\State threadState $\leftarrow$ first element of waitingQueue
			\For{each ThreadState ts in waitingQueue}
				\If{ts has higher priority than threadState}
					\State threadState $\leftarrow$ ts
				\EndIf
			\EndFor
		\Else
			\State thread $\leftarrow$ null
		\EndIf
		\State \Return thread
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\caption{ThreadState}
	\begin{algorithmic}
		\State $//$ once new thread enter, all the EP should change
		\Procedure {change()}{}
			\If{!changed}
				\State changed $\leftarrow$ true
				\State EP $\leftarrow$ getEP()
				\For{each PriorityQueue pq in acquiredResource}
					\If{pq.master != null $\&\&$ transferPriority}
						\State pq.changed $\leftarrow$ true
						\State pq.master.change()
					\EndIf
				\EndFor
			\EndIf
		\EndProcedure
	\end{algorithmic}
	\begin{algorithmic}
    \Procedure {getEP()}{}
			\If{changed}
				\State EP $\leftarrow$ priority
				\For{each PriorityQueue pq in occupiedQueue}
					\State EP $\leftarrow$ MAX(EP, pq.getMaxEP)
				\EndFor
			\EndIf
			\State \Return EP
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}
	\begin{algorithmic}
    \Procedure {setPriority}{int Priority}
			\If{priority != Priority}
				\State priority $\leftarrow$ Priority
				\State change()
			\EndIf
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {waitForAccess}{PriorityQueue waitQueue}
			\State Add waitQueue into acquiredResource
			\If{waitQueue is in occupiedResource}
				\State Remove waitQueue from occupiedResource
				\State waitQueue.master $\leftarrow$ null
			\EndIf
			\If{waitQueue.master != null}
				\State $//$ new thread wait hence EP should change
				\If{transferPriority}
					\State waitQueue.changed $\leftarrow$ true
					\State waitQueue.master.change()
				\EndIf
			\EndIf
		\EndProcedure
  \end{algorithmic}
	\begin{algorithmic}
    \Procedure {acquire}{PriorityQueue waitQueue}
			\State Add waitQueue into occupiedResource
			\If{waitQueue is in acquiredResource}
				\State Remove waitQueue from acquiredResource
				\State waitQueue.master $\leftarrow$ this
			\EndIf
			\State change()
		\EndProcedure
  \end{algorithmic}
\end{algorithm}
\subsection{Testing Plan}
\begin{enumerate}
	\item Set up serveral threads with random priorities associated with one condition. And test whether they execute in decreasing order.
	\item Set up serveral threads with random priorities associated with mutiple conditions. And test whether they execute in decreasing order. And
		Test by printing that whether the waiting thread properly donate its priority and whether the quit-holding thread recover its priority.
\end{enumerate}
\section{Solution to \texttt{Boat} Problem}
\subsection{Overview}

Implement \texttt{Boat} class to solve the boat problem.

\subsection{Correctness Constraints}

\begin{enumerate}
\item[$\bullet$] The boat can only hold one or two children or one adult.
\item[$\bullet$] Each time the location of the boat changes, the number of passengers in boat cannot be zero.
\item[$\bullet$] \texttt{begin} method finished with both of children and adults is on Molokai.
\end{enumerate}

\subsection{Declaration}

\begin{enumerate}
\item[$\bullet$] In \texttt{Boat} class, add \texttt{locationOfBoat}, \texttt{numOfChildOahu}, \texttt{numOfAdultOahu}, \texttt{numOfChildMolokai}, \texttt{numOfAdultMolokai}, \texttt{numOfChildBoat}, \texttt{boatLock}, \texttt{waitOnOahuCondition}, \texttt{waitBoardingCondition}, \texttt{waitOnMolokaiCondition}, and \texttt{message} a \texttt{Communicator}.
\item[$\bullet$] In \texttt{begin}, what we need to do is for each children and adults create a thread, and we also use message to see whether we have move all people to Molokai.
\item[$\bullet$] In \texttt{AdultItinerary}, the adult can  move to Molokai when the boat is at Oahu and empty with child on Molokai can't be zero. Then we move this adult to Molokai and wake waiting on Molokai.
\item[$\bullet$] In \texttt{ChildItinerary}, add \texttt{location} to show the location of this child. For child move to Molokai, the condition is boat is at Oahu and empty or with one child, and also the child can't be himself. If the child is the first in the boat, then it wait for another to board. If the location of the boat is on Molokai, then it must have one child back to Oahu.
\end{enumerate}

\subsection{Description}

\begin{algorithm}
    \begin{algorithmic}
    \Procedure{begin}{int adults, int children, BoatGrader b}
        \State bg $\leftarrow$ b
        \State for each childs, create a thread of \texttt{ChildItinerary}
        \State for each adults, create a thread of \texttt{AdultItinerary}
        \While{message.listen() is not the total of children and adults}
        \EndWhile
    \EndProcedure
    \Procedure{AdultItinerary}{}
        \State numOfAdultOahu++
        \State boatLock.acquire()
        \While{locationOfBoat is not Oahu or numOfChildBoat > 0 or numOfChildOahu > 1}
            \If{locationOfBoat is on Oahu}
                \State waitOnOahuCondition.wakeAll()
            \EndIf
            \State waitOnOahuCondition.sleep()
        \EndWhile
        
        \State bg.AdultRowToMolokai()
        \State numOfAdultOahu--, numOfAdultMolokai++
        \State locationOfBoat is Molokai
        \State message.speak(numOfAdultMolokai + numOfChildMolokai)
        \State waitOnMolokaiCondition.wakeAll()
        \State boat.release()        
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
\begin{algorithm}
    \begin{algorithmic}
    \Procedure{ChildItinerary}{}
        \State location is Oahu
        \State numOfChildOahu++
        \While{true}
            \State boat.acquire()
            \If{location is Oahu}
                \While{locationOfBoat is not Oahu or numOfChildBoat is 2 or numOfChildOahu is 1}
                    \If{locationOfBoat is Oahu}
                        \State waitOnOahuCondition.wakeAll()
                    \EndIf
                    \State waitOnOahuCondition.sleep()
                \EndWhile
                \State numOfChildBoat++
                \If{numOfChildBoat == 1}
                    \State waitOnOahuCondition.wakeAll()
                    \State waitBoardingCondition.sleep()
                    \State numOfChildOahu--
                    \State bg.ChildRideToMolokai()
                    \State location is Molokai
                    \State numOfChildBoat $\leftarrow$ 0
                    \State numOfChildMolokai++
                    \State message.speak(numOfAdultMolokai + numOfChildMolokai)
                    \State waitOnMolokaiCondition.wakeAll()
                    \State waitOnMolokaiCondition.sleep()
                \Else
                    \State waitBoardingCondition.wake()
                    \State numOfChildOahu--
                    \State bg.ChildRowToMolokai()
                    \State location is Molokai
                    \State numOfChildMolokai++
                    \State waitOnMolokaiCondition.sleep()
                \EndIf
            \Else
                \While{locationOfBoat is not Molokai}
                    \State waitOnMolokaiCondition.sleep()
                \EndWhile
                \State numOfChildMolokai--
                \State bg.ChildRowToOahu()
                \State location is Oahu
                \State locationOfBoat is Oahu
                \State numOfChildOahu++
                \State waitOnOahuCondition.wakeAll()
                \State waitOnOahuCondition.sleep()
            \EndIf
            \State boat.release()
        \EndWhile
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Testing Plan}

For this problem, the test is easy, just some examples with different numbers of adults or children.
\end{document}
